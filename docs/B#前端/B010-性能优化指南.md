# 性能优化指南

## 📋 概述

本文档提供前端项目的性能优化策略和最佳实践，帮助提升应用的加载速度、运行效率和用户体验。

## 🎯 性能目标

### Core Web Vitals 目标

| 指标 | 目标值 | 说明 |
|------|--------|------|
| LCP (Largest Contentful Paint) | < 2.5s | 最大内容绘制时间 |
| FID (First Input Delay) | < 100ms | 首次输入延迟 |
| CLS (Cumulative Layout Shift) | < 0.1 | 累积布局偏移 |
| FCP (First Contentful Paint) | < 1.8s | 首次内容绘制 |
| TTFB (Time to First Byte) | < 600ms | 首字节时间 |

## 🚀 已实现的优化

### 1. 代码分割和懒加载

#### React.lazy 懒加载

```typescript
// App.lazy.tsx
const HomePage = lazy(() => import('./pages/home/HomePage'));
const PromptBuilderPage = lazy(() => import('./pages/generator/PromptBuilderPage'));
const MyTemplatesPage = lazy(() => import('./pages/templates/MyTemplatesPage'));
const APIConfigPage = lazy(() => import('./pages/config/APIConfigPage'));
```

#### 路由级代码分割

```typescript
<Suspense fallback={<PageLoading />}>
    <Routes>
        <Route path='/' element={<HomePage />} />
        <Route path='/generator' element={<PromptBuilderPage />} />
        {/* ... */}
    </Routes>
</Suspense>
```

### 2. 防抖和节流

#### useDebounce Hook

```typescript
// 搜索输入防抖
const debouncedSearchTerm = useDebounce(searchTerm, 300);
```

#### useDebouncedCallback Hook

```typescript
// 自动保存防抖
const debouncedSave = useDebouncedCallback(saveData, 1000);
```

#### useThrottle Hook

```typescript
// 滚动事件节流
const throttledScroll = useThrottle(scrollPosition, 100);
```

### 3. 自动保存优化

```typescript
// useAutoSave Hook
const { isSaving, lastSaved } = useAutoSave(data, saveFunction, {
    delay: 2000,
    enabled: true
});
```

### 4. 响应式优化

```typescript
// useResponsive Hook
const { isMobile, isTablet, isDesktop } = useResponsive();

// 根据设备类型加载不同组件
{isMobile ? <MobileView /> : <DesktopView />}
```

### 5. 本地存储优化

```typescript
// useLocalStorage Hook
const [data, setData] = useLocalStorage('key', defaultValue);

// 自动序列化和反序列化
// 自动处理存储错误
```

## 🔧 性能优化工具

### 性能测量

```typescript
import { measurePerformance } from './utils/performance';

measurePerformance('数据处理', () => {
    // 执行耗时操作
    processData();
});
```

### Web Vitals 监控

```typescript
import { getWebVitals } from './utils/performance';

// 在生产环境监控性能指标
getWebVitals();
```

### 网络状态检测

```typescript
import { getNetworkStatus } from './utils/performance';

const status = getNetworkStatus();
console.log('在线状态:', status.online);
console.log('网络类型:', status.effectiveType);
```

### 内存使用监控

```typescript
import { getMemoryUsage } from './utils/performance';

const memory = getMemoryUsage();
if (memory) {
    console.log('已使用内存:', memory.usedJSHeapSize);
}
```

## 📦 构建优化

### 1. 生产构建配置

```json
// package.json
{
    "scripts": {
        "build": "react-scripts build",
        "analyze": "source-map-explorer 'build/static/js/*.js'"
    }
}
```

### 2. 环境变量优化

```env
# .env.production
GENERATE_SOURCEMAP=false  # 禁用 source map
REACT_APP_API_BASE_URL=/api
```

### 3. 代码压缩

- JavaScript 压缩（Terser）
- CSS 压缩（cssnano）
- HTML 压缩

## 🌐 网络优化

### 1. Nginx 配置

#### Gzip 压缩

```nginx
gzip on;
gzip_vary on;
gzip_min_length 1024;
gzip_types text/plain text/css text/xml text/javascript
           application/x-javascript application/xml+rss
           application/json application/javascript;
```

#### 静态资源缓存

```nginx
location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
    expires 1y;
    add_header Cache-Control "public, immutable";
}
```

### 2. 资源预加载

```typescript
import { preloadResource, preconnect } from './utils/performance';

// 预加载关键资源
preloadResource('/fonts/main.woff2', 'font');

// 预连接到 API 服务器
preconnect('https://api.example.com');
```

### 3. 图片懒加载

```typescript
import { lazyLoadImage } from './utils/performance';

// 使用 data-src 属性
<img data-src="/path/to/image.jpg" alt="描述" />

// 应用懒加载
const img = document.querySelector('img');
lazyLoadImage(img);
```

## 🎨 渲染优化

### 1. React.memo

```typescript
// 避免不必要的重渲染
const MemoizedComponent = React.memo(Component, (prevProps, nextProps) => {
    return prevProps.id === nextProps.id;
});
```

### 2. useMemo

```typescript
// 缓存计算结果
const expensiveValue = useMemo(() => {
    return computeExpensiveValue(a, b);
}, [a, b]);
```

### 3. useCallback

```typescript
// 缓存回调函数
const handleClick = useCallback(() => {
    doSomething(a, b);
}, [a, b]);
```

### 4. 虚拟滚动

对于长列表，使用虚拟滚动：

```typescript
import { FixedSizeList } from 'react-window';

<FixedSizeList
    height={600}
    itemCount={1000}
    itemSize={50}
    width="100%"
>
    {Row}
</FixedSizeList>
```

## 🔄 异步优化

### 1. 批量处理

```typescript
import { batchProcess } from './utils/performance';

// 批量处理大量数据，避免阻塞主线程
await batchProcess(items, async (item) => {
    await processItem(item);
}, 10); // 每批处理 10 个
```

### 2. 空闲时执行

```typescript
import { runWhenIdle } from './utils/performance';

// 在浏览器空闲时执行低优先级任务
runWhenIdle(() => {
    performLowPriorityTask();
}, { timeout: 2000 });
```

### 3. 函数记忆化

```typescript
import { memoize } from './utils/performance';

// 缓存函数结果
const expensiveFunction = memoize((a, b) => {
    // 耗时计算
    return a + b;
});
```

## 📊 性能监控

### 1. 开发环境监控

```typescript
// 使用 React DevTools Profiler
<Profiler id="App" onRender={onRenderCallback}>
    <App />
</Profiler>
```

### 2. 生产环境监控

```typescript
// 集成 Web Vitals
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

function sendToAnalytics(metric) {
    // 发送到分析服务
    console.log(metric);
}

getCLS(sendToAnalytics);
getFID(sendToAnalytics);
getFCP(sendToAnalytics);
getLCP(sendToAnalytics);
getTTFB(sendToAnalytics);
```

## 🎯 优化检查清单

### 代码层面

- [x] 使用 React.lazy 和 Suspense 实现代码分割
- [x] 使用 React.memo 避免不必要的重渲染
- [x] 使用 useMemo 和 useCallback 优化计算和回调
- [x] 实现防抖和节流
- [x] 使用虚拟滚动处理长列表
- [x] 避免在渲染中进行复杂计算

### 资源层面

- [x] 压缩 JavaScript 和 CSS
- [x] 优化图片（使用 WebP、压缩）
- [x] 实现图片懒加载
- [x] 使用字体子集
- [x] 移除未使用的代码

### 网络层面

- [x] 启用 Gzip 压缩
- [x] 配置静态资源缓存
- [x] 使用 CDN（可选）
- [x] 实现资源预加载
- [x] 减少 HTTP 请求数量

### 构建层面

- [x] 配置生产环境构建
- [x] 禁用 source map（生产环境）
- [x] 使用构建分析工具
- [x] 优化依赖包大小
- [x] Tree shaking

## 📈 性能测试

### 使用 Lighthouse

```bash
# 安装 Lighthouse
npm install -g lighthouse

# 运行测试
lighthouse http://localhost:3100 --view
```

### 使用 Chrome DevTools

1. 打开 Chrome DevTools
2. 切换到 Performance 标签
3. 点击录制按钮
4. 执行操作
5. 停止录制并分析结果

### 使用 React DevTools Profiler

1. 安装 React DevTools 扩展
2. 打开 Profiler 标签
3. 点击录制按钮
4. 执行操作
5. 分析组件渲染性能

## 🔍 性能问题排查

### 常见性能问题

#### 1. 组件频繁重渲染

**问题**: 组件在不需要更新时也重新渲染

**解决方案**:

```typescript
// 使用 React.memo
const Component = React.memo(MyComponent);

// 使用 useMemo 缓存计算结果
const value = useMemo(() => compute(), [deps]);

// 使用 useCallback 缓存回调
const callback = useCallback(() => {}, [deps]);
```

#### 2. 大列表渲染慢

**问题**: 渲染大量列表项导致性能下降

**解决方案**:

```typescript
// 使用虚拟滚动
import { FixedSizeList } from 'react-window';
```

#### 3. 频繁的状态更新

**问题**: 输入框等频繁触发状态更新

**解决方案**:

```typescript
// 使用防抖
const debouncedValue = useDebounce(value, 300);
```

#### 4. 内存泄漏

**问题**: 组件卸载后仍有定时器或订阅

**解决方案**:

```typescript
useEffect(() => {
    const timer = setTimeout(() => {}, 1000);

    return () => {
        clearTimeout(timer); // 清理定时器
    };
}, []);
```

## 📚 参考资源

- [Web Vitals](https://web.dev/vitals/)
- [React Performance Optimization](https://react.dev/learn/render-and-commit)
- [Lighthouse](https://developers.google.com/web/tools/lighthouse)
- [Chrome DevTools](https://developer.chrome.com/docs/devtools/)

---

**文档版本**: 1.0.0
**最后更新**: 2024年
**维护者**: 前端开发团队
